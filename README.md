# ReLearning-To-Code-Again
I wanted to go back to basics and relearn coding skills. I've a mature head and want to apply that to relearning skills I scanned before and, truthfully, did not absorb. Lets see if I can change that.

I found this list on threads ( https://www.threads.com/@ammaryasser314/post/DP6maKgDIaR?xmt=AQF0L5Eupc2RtDTa2-D1vdf5SJCgSlSlCsrqD6SDCLsR4g ) which advocated picking a coding language and a proposed set of algorithms to develop.

➊ Arrays
    ➀ Creating an Array
    ➁ Iterate through Array
    ➂ Get an Element
    ➃ Search an Element
    ➄ Insert Element(s)
    ➅ Delete Element(s)
    ➆ Filter an Array
    ➇ Fetch a Sub-Array
    ➈ Merging Arrays
    ➉ Reverse Array
    ➀➀ Rotate Array

➋ Linked Lists
    ➀ Creating a Linked List
    ➁ Iterate through Linked List
    ➂ Get an Element
    ➃ Find an Element
    ➤ Insert Element(s)
        ➄ At Start
        ➅ At End
        ➆ At Anywhere
    ➤ Delete Element(s)
        ➇ From Start
        ➈ From End
        ➉ From Anywhere
    ➀➀ IsEmpty
    ➀➁ Merging Linked Lists
    ➀➂ Reverse Linked List
    ➀➃ Check for Cycles
    Implement these algorithms for linked lists, double linked lists, circular linked lists, etc.

➌ Stacks
    ➀ Push
    ➁ Pop
    ➂ IsEmpty
    ➃ IsFull
    ➄ Peek
    ➅ Size
    Implement the stack using both Array and Linked List.

➍ Queues (also Priority Queue)
    ➀ Enqueue
    ➁ Dequeue
    ➂ IsEmpty
    ➃ IsFull
    ➄ Peek
    ➅ Size
    ➆ Update Priority
    * Implement the queue using both Array and Linked List.
    ** Implement these for a Priority Queue

➎ Hash Tables
    ➤ Hash Function
        ➀ Division Method
        ➁ Multiplication Method
        ➂ Universal Hashing
    ➤ Hash Collision
        ➃ Collision Resolution
    ➤ Open Addressing
        ➄ Linear Probing
        ➅ Quadratic Probing
        ➆ Double Hashing

➏ Trees
    ➀ Traversal
    ➁ Height of a Node/Tree
    ➂ Depth of a Node
    ➃ Degree of a Node
    ➤ Traversal
        ➄ In Order
        ➅ Pre Order
        ➆ Post Order
        ➇ Level Order
        ➈ Insert
        ➉ Delete

➐ Binary Search Tree
    ➀ Formation of a BST
    ➁ Insert a Node
    ➂ Delete a Node
    ➃ Search for a Node
    ➤ Traversal
        ➄, ➅, ➆: In Order, Pre Order, Post Order
        ➇ & ➈ Find Min, Max
        ➉ & ➀➀ Find Predecessor & Successor
    ➤ Balance a BST
        ➀➁ AVL Tree
        ➀➂ Red-Black Tree

➑ Heaps
    ➀ Heapify
    ➁ Insert Element
    ➂ Delete Element
    ➃ Peek (Max/Min Element)
    ➄ Extract (Max/Min Element)
    Implement Min Heap, Max Heap, Binary Heap, and Fibonacci Heap.

➒ Suffix Tree
    ➀ Construct a suffix tree
    ➁ Pattern Matching
    ➂ Substring Checking
    ➃ Longest Common Substring
    ➄ Longest Repeated Substring
    ➅ Substring Frequency
    ➆ Edit Distance
    ➇ Suffix Links
    ➈ Finding all palindromic substrings

➓ Trie
    ➀ Insertion in a Trie
    ➁ Search for a word in a Trie
    ➂ Prefix Search
    ➃ Delete a word from the Trie
    ➄ Find the count of a word in a Trie
    ➅ Longest Common Prefix  

➊➊ Disjoint Set
    ➀ Union
    ➁ Find
    ➂ Path Compression
    ➃ Union by Rank
    ➄ Union by Size

➊➋ Graphs
    ➤ Adjacency Matrix
        ➀ Add Edge
        ➁ Remove Edge
    ➤ Adjacency List
        ➂ Add Edge
        ➃ Remove Edge
    ➤ Traverse Nodes
        ➄ Depth First Search
        ➅ Breadth First Search
    ➤ Shortest Path
        ➆ Dijkstra's Algorithm
        ➇ Floyd-Warshall Algorithm
        ➈ Bellman Ford Algorithm
    ➤ Minimum Spanning Tree
        ➉ Kruskal's Algorithm
        ➀➀ Prim's Algorithm
    ➤ Connectivity
        ➀➁ Check connectivity b/w nodes
        ➀➂ Find all paths

Connectivity
    ➀➃ Articulation points
    ➀➄ Bridges
    ➀➅ Hamiltonian Path
    ➀➆ Hamiltonian Cycle
    ➀➇ Eulerian Path
    ➀➈ Eulerian Cycle

20. Find # of islands
    ➁➀ Transitive Closure
    ➁➁ Graph Cycle
    ➤ Topological Sorting
        ➁➂ Find all topological sorting
        ➁➃ Kahn's Algorithm
        ➁➄ Longest Path
    ➤ Flow Network
        ➁➅ Ford-Fulkerson Algorithm
        ➁➆ Edmonds–Karp algorithm
        ➁➇ Dinic's Algorithm

➊➌ Searching Algorithms
    ➀ Linear Search
    ➁ Jump Search
    ➂ Binary Search
    ➃ Interpolation Search
    ➄ Exponential Search
    ➅ Ternary Search

➊➍ Sorting Algorithms
    ➀ Bubble Sort
    ➁ Selection Sort
    ➂ Insertion Sort
    ➃ Merge Sort
    ➄ Quick Sort

And, a few advanced ones,
    ➅ Binary Insertion Sort
    ➆ 3-way Merge Sort
    ➇ 3-way Quick Sort
    ➈ Counting Sort
    ➉ Radix Sort
    ➀➀ Bucket Sort
    ➀➁ Heap Sort
    ➀➂ Shell Sort
    ➀➃ Tim Sort
    ➀➄ Odd-Even Sort
    ➀➅ Comb Sort
    ➀➆ Cocktail Sort
    ➀➇ Tree Sort
    ➀➈ Cartesian Sort
    20. Pigeonhole Sort
    ➁➀ Cycle Sort
    ➁➁ Strand Sort
    ➁➂ Pancake Sort
    ➁➃ Permutation Sort
    ➁➄ Gnome Sort
    ➁➅ Bitonic Sort
    ➁➆ Sleep Sort

➊➎ Greedy Algorithms
    ➀ Greedy Coin Change Problem
    ➁ Activity Selection Problem
    ➂ Fractional Knapsack Problem
    ➃ Huffman Coding
